<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>卷積神經網路</title>
    <link href="/2022/12/30/%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF/"/>
    <url>/2022/12/30/%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<ul><li><p>卷積神經網路起源</p><ol><li>卷積神經網路 vs 全聯接神經網路</li><li>發展脈絡與意義</li></ol></li><li><p>卷積神經網路構建</p><ol><li>卷積層</li><li>其他功能層(池話層，非線性激勵層，歸一化層，切分&#x2F;融合層)</li><li>相關推倒</li><li>使用要點</li></ol></li><li><p>卷積神經網路應用</p></li><li><p>可視化事例與代碼講解(TensorFlow,Pytorch)</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>從阿拉伯數字辨識能力了解CNN</title>
    <link href="/2022/12/25/%E5%BE%9E%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B8%E5%AD%97%E8%BE%A8%E8%AD%98%E8%83%BD%E5%8A%9B%E4%BA%86%E8%A7%A3CNN/"/>
    <url>/2022/12/25/%E5%BE%9E%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B8%E5%AD%97%E8%BE%A8%E8%AD%98%E8%83%BD%E5%8A%9B%E4%BA%86%E8%A7%A3CNN/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>機器學習新手村</title>
    <link href="/2022/12/24/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E6%96%B0%E6%89%8B%E6%9D%91/"/>
    <url>/2022/12/24/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E6%96%B0%E6%89%8B%E6%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="線性回歸"><a href="#線性回歸" class="headerlink" title="線性回歸"></a>線性回歸</h2><hr><h3 id="回歸問題是什麼"><a href="#回歸問題是什麼" class="headerlink" title="回歸問題是什麼?"></a>回歸問題是什麼?</h3><ol><li>分類問題<ol><li>到銀行借錢，銀行回答會或不會(明確類別)</li></ol></li><li>回歸問題(有監督算法)<ol><li>到銀行借錢，問銀行能借我多少(一定範圍找尋可能值)</li></ol></li></ol><h3 id="線性回歸例子"><a href="#線性回歸例子" class="headerlink" title="線性回歸例子"></a>線性回歸例子</h3><hr><pre><code class="hljs">x1       x2      y      | Y = x1*θ1 + x2θ*2     </code></pre><p>在數據中添加X0恆等1來方便對線性方程轉換為矩陣</p><p>在機器學習中，所有運算皆使用 <strong>矩陣</strong> </p><table><thead><tr><th>工資</th><th>年齡</th><th>額度</th></tr></thead><tbody><tr><td>4000</td><td>25</td><td>20000</td></tr><tr><td>8000</td><td>30</td><td>70000</td></tr><tr><td>5000</td><td>28</td><td>35000</td></tr><tr><td>7500</td><td>33</td><td>55000</td></tr><tr><td>12000</td><td>40</td><td>85000</td></tr></tbody></table><ol><li>一個例子<ol><li>數據：工資和年齡(2個特徵)</li><li>目標：預測銀行帶給我多少錢(標籤)</li><li>考慮：工資和年齡都會影響最終銀行貸款的結果，那麼他們各自有多大的影響呢？(參數)</li></ol></li><li>由上述Y方程式知道求出 <strong>θ(標籤)</strong> 為目標-&gt;求出解決</li><li>數學來了！<ol><li>假設θ1是年齡參數，θ2是工資參數</li><li>擬合平面h(x)&#x3D;<code>θ0*x0+θ1*x1+θ2*x2</code>(θ0是偏值項)</li><li>將h(x)整合成矩陣表達<code>h(x)=∑(i=0-&gt;n)=θ^Tx</code></li></ol></li><li>誤差(使用i代表任意項)<ol><li>真實值和預測值間肯定具有誤差ϵ</li><li>對於每個樣本 <code>y^(i)=θ^T x^(i)+ ϵ^(i)</code></li></ol></li><li>分析誤差<ol><li></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2022/12/23/http/"/>
    <url>/2022/12/23/http/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><h3 id="api→懂原理"><a href="#api→懂原理" class="headerlink" title="api→懂原理"></a>api→懂原理</h3><h3 id="通信-tcp高併發"><a href="#通信-tcp高併發" class="headerlink" title="通信,tcp高併發"></a>通信,tcp高併發</h3><h3 id="分布式-為服務"><a href="#分布式-為服務" class="headerlink" title="分布式,為服務"></a>分布式,為服務</h3><h3 id="微服務⇒RPC⇒內核-socket—→IO-⇒-BIO-NIO-EPOLL"><a href="#微服務⇒RPC⇒內核-socket—→IO-⇒-BIO-NIO-EPOLL" class="headerlink" title="微服務⇒RPC⇒內核(socket—→IO) ⇒ BIO,NIO,EPOLL"></a>微服務⇒RPC⇒內核(socket—→IO) ⇒ BIO,NIO,EPOLL</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">IO 是連結<br><br>消息/請求可不可以複用連結(多路服用單純是狀態=&gt;RW)=&gt;連結不能服用<br><br>根據消息或請求狀態判斷使否有連節<br><br>假設有一個c(client)有兩個線成,如果同時請求一個服務器,因為HTTP是無狀態<br>=&gt;回傳的消息並不知道是客戶端的哪一個線成=&gt;因此連結不得複用<br><br>正確方式：<br>先線程鎖死連結,完成釋放後再將鎖打開,其他線程在進行請求<br></code></pre></td></tr></table></figure><h1 id="OSI七層模型"><a href="#OSI七層模型" class="headerlink" title="OSI七層模型"></a>OSI七層模型</h1><hr><h3 id="從7層參考模型到5層實際模型"><a href="#從7層參考模型到5層實際模型" class="headerlink" title="從7層參考模型到5層實際模型"></a>從7層參考模型到5層實際模型</h3><h3 id="五層模型中的應用層包含7層模型中的"><a href="#五層模型中的應用層包含7層模型中的" class="headerlink" title="五層模型中的應用層包含7層模型中的"></a>五層模型中的應用層包含7層模型中的</h3><ol><li>應用層</li><li>表示層</li><li>會話層</li></ol><h3 id="⇒應用層可以有不同的通信程序-需要個性化"><a href="#⇒應用層可以有不同的通信程序-需要個性化" class="headerlink" title="⇒應用層可以有不同的通信程序,需要個性化"></a>⇒應用層可以有不同的通信程序,需要個性化</h3><h3 id="內核主要圍繞tcp-x2F-ip協議⇒內核中包含的五層模型"><a href="#內核主要圍繞tcp-x2F-ip協議⇒內核中包含的五層模型" class="headerlink" title="內核主要圍繞tcp&#x2F;ip協議⇒內核中包含的五層模型"></a>內核主要圍繞tcp&#x2F;ip協議⇒內核中包含的五層模型</h3><ol><li>傳輸控制層</li><li>網路層</li><li>鏈路層</li></ol><h3 id="⇒內核是無法被更動的"><a href="#⇒內核是無法被更動的" class="headerlink" title="⇒內核是無法被更動的"></a>⇒內核是無法被更動的</h3><p>EX:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><br><span class="hljs-attribute">nc</span> <span class="hljs-operator">=</span>&gt;保持建立一個連接<br>nc www.google.com <span class="hljs-operator">=</span>&gt;回車後需要 輸入 方法 網址 協議<br><br>GET / HTTP/<span class="hljs-number">1.0</span><br><br>並非每個程序的方法都相同<span class="hljs-operator">=</span>&gt;應用層個性化<br></code></pre></td></tr></table></figure><h3 id="任何協議都會需要內存幫忙"><a href="#任何協議都會需要內存幫忙" class="headerlink" title="任何協議都會需要內存幫忙"></a>任何協議都會需要內存幫忙</h3><p>nc就是掉用傳輸控制層</p><h1 id="什麼是傳輸控制層"><a href="#什麼是傳輸控制層" class="headerlink" title="什麼是傳輸控制層 ?"></a>什麼是傳輸控制層 ?</h1><hr><h3 id="TCP協議和UDP協議都在這層"><a href="#TCP協議和UDP協議都在這層" class="headerlink" title="TCP協議和UDP協議都在這層"></a>TCP協議和UDP協議都在這層</h3><h2 id="解釋tcp"><a href="#解釋tcp" class="headerlink" title="解釋tcp"></a>解釋tcp</h2><p>⇒面相連結的可靠傳輸控制協議</p><p>⇒三次握手</p><h3 id="什麼叫三次握手-（傳輸控制層"><a href="#什麼叫三次握手-（傳輸控制層" class="headerlink" title="什麼叫三次握手?（傳輸控制層"></a>什麼叫三次握手?（傳輸控制層</h3><p>後端先做一個數據包發給對方syn(空的數據包⇒控制</p><p>服務端接受後會發syn+ack</p><p>後端會發給服務端ack</p><p>三次握手後內核會開出內存空間buffer</p><p>後端有,服務端也有</p><p>而所謂的連接就是雙方所開闢的資源的過程⇒有空間就有連結</p><p>站在程序的角度,只能看到內存空間,對空間讀(字節數組)或寫並不明白握手細節</p><h2 id="程序只和內存空間打交道"><a href="#程序只和內存空間打交道" class="headerlink" title="程序只和內存空間打交道"></a>程序只和內存空間打交道</h2><h3 id="程序連結使用socket底層就是內存和tcp三次握手"><a href="#程序連結使用socket底層就是內存和tcp三次握手" class="headerlink" title="程序連結使用socket底層就是內存和tcp三次握手"></a>程序連結使用socket底層就是內存和tcp三次握手</h3><h1 id="socket套接字"><a href="#socket套接字" class="headerlink" title="socket套接字"></a>socket套接字</h1><hr><h3 id="fd-四元組⇒ip-port-客戶端-ip-port-服務端-唯一標示"><a href="#fd-四元組⇒ip-port-客戶端-ip-port-服務端-唯一標示" class="headerlink" title="fd : 四元組⇒ip:port(客戶端) + ip:port(服務端) 唯一標示"></a>fd : 四元組⇒ip:port(客戶端) + ip:port(服務端) 唯一標示</h3><p>程序拿到的是fd(標示幅)</p><p>port(端口號)使用數字來表示數據包,有65535個</p><p>例子：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">IPA(客戶端)⇒啟用app<br><br>IPB(服務端)⇒生成TOCMAT端口號為<span class="hljs-number">80</span><br><br>請問IPA對IPB(TOCMAT)能建立多少socket(連接)<br><br>/--------------------------------------------/<br><br>客戶端具備I<span class="hljs-symbol">PA:1</span> + I<span class="hljs-symbol">PB:80</span><br>服務端具備I<span class="hljs-symbol">PA:1</span> + I<span class="hljs-symbol">PB:80</span><br><br>能改動客戶端的端口號而總數量的端口號有<span class="hljs-number">65536</span><br>因此能夠建立的連結為<span class="hljs-number">6</span>萬多個<br><br>/------------------------------------------/<br><br>若服務器建立好,請問消耗多少端口號=&gt;只有一個<span class="hljs-number">80</span><br><br>如果有一個客戶端想請求超過<span class="hljs-number">6</span>萬多(端口總數)的數量對服務端,請問能否成功<br>=&gt;能,只要客戶端創造出不同的IP就能超過<br><br>/------------------------------------------/<br><br>若服務端再出現一個程序ngi<span class="hljs-symbol">nx:90</span><br>請問能否再開連接(端口已被佔滿)=&gt;能,因為服務端端口號不一樣,能夠區分出唯一性<br>=&gt;socket合法,因此可以再創造<span class="hljs-number">6</span>萬多個連接<br></code></pre></td></tr></table></figure><h3 id="只要不同ip可以創造無限多個socket"><a href="#只要不同ip可以創造無限多個socket" class="headerlink" title="只要不同ip可以創造無限多個socket"></a>只要不同ip可以創造無限多個socket</h3><h3 id="數據傳輸⇒TCP-→-三次握手-→-數據傳輸-需要斷開連接-→-四次分手"><a href="#數據傳輸⇒TCP-→-三次握手-→-數據傳輸-需要斷開連接-→-四次分手" class="headerlink" title="數據傳輸⇒TCP → 三次握手 → 數據傳輸 (需要斷開連接) → 四次分手"></a>數據傳輸⇒TCP → 三次握手 → 數據傳輸 (需要斷開連接) → 四次分手</h3><h1 id="什麼是四次分手"><a href="#什麼是四次分手" class="headerlink" title="什麼是四次分手"></a>什麼是四次分手</h1><hr><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">有一個客戶端和服務端<br>當客戶端傳送了一個fin信號給服務端 =&gt;第一次握手<br>服務端接受後回傳一個fin+ack給客戶端 =&gt;第二次握手<br><br><span class="hljs-keyword">if</span> 在這時候端開連接呢<br> 客戶端的資源放掉後,服務端的資源還是保留=&gt;服務端資源無法找到相對應具備關係的客戶端資源=&gt;無法正常連結<br><br>當服務端主動向客戶端傳送fin信號時 =&gt;達成第三次握手<br>客戶端接受後回傳ack給服務端 =&gt;四次分手<br><br>第三次握手和第四此可以結合在一起<br></code></pre></td></tr></table></figure><h3 id="演示四次分手"><a href="#演示四次分手" class="headerlink" title="演示四次分手"></a>演示四次分手</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">使用tcpdump必須登入root =&gt;輸入su後password輸入root<br>ifconfig =&gt;查看可用網路卡位置<br>tcpdump =&gt;抓包<br>curl =&gt;完成連結且GET後輸出並退出<br><br>EX:<br>tcpdump -nn -i any port <span class="hljs-number">80</span><br><br>開啟另一個窗口<br>curl www.google.com<br></code></pre></td></tr></table></figure><h3 id="三次握手建立通訊"><a href="#三次握手建立通訊" class="headerlink" title="三次握手建立通訊"></a>三次握手建立通訊</h3><p>[S] &#x3D; syn</p><p>[S.] &#x3D; syn+ack</p><p>[.] &#x3D; ack</p><h3 id="數據傳輸"><a href="#數據傳輸" class="headerlink" title="數據傳輸"></a>數據傳輸</h3><p>每一個[P]都會搭一個[.] ⇒不斷出現且length都不一樣代表在拆包</p><h3 id="四次分手取決於協議⇒要不要保持連結"><a href="#四次分手取決於協議⇒要不要保持連結" class="headerlink" title="四次分手取決於協議⇒要不要保持連結"></a>四次分手取決於協議⇒要不要保持連結</h3><h3 id="傳輸控制層完成握手後發送包必須依靠網路層"><a href="#傳輸控制層完成握手後發送包必須依靠網路層" class="headerlink" title="傳輸控制層完成握手後發送包必須依靠網路層"></a>傳輸控制層完成握手後發送包必須依靠網路層</h3><h1 id="網路層⇒走路由表"><a href="#網路層⇒走路由表" class="headerlink" title="網路層⇒走路由表"></a>網路層⇒走路由表</h1><hr><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><h3 id="路由-⇒-默認網關⇒數據過來會下一跳⇒到另一個網卡"><a href="#路由-⇒-默認網關⇒數據過來會下一跳⇒到另一個網卡" class="headerlink" title="路由 ⇒ 默認網關⇒數據過來會下一跳⇒到另一個網卡"></a>路由 ⇒ 默認網關⇒數據過來會下一跳⇒到另一個網卡</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">使用netstat -nr查看所有路由<br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">ping www.google.com =&gt;需要經過網關<br><br>ping <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span> =&gt;不需要網關<br><br>ping的原理:<br>拿到目標ip後到路由表和遮罩進行匹配(<span class="hljs-number">2</span>進位運算) =&gt;遮罩通常為<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>然後看是否在Destination有相同地址<br><span class="hljs-keyword">if</span> 有 =&gt;到gateway查看<br>如果出現<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>代表在局域網,不需要網關<br><br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">arp</span> -a<br><br>查看網路的<span class="hljs-built_in">ip</span>地址所對應到的硬件網卡上的地址<br><br></code></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq">arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.2</span> &amp;&amp; curl www.google:<span class="hljs-number">80</span><br><br>先刪除內核裡的對應地址再進行請求=&gt;curl調用內核建立握手=&gt;發現沒有位置後調用arp協議=&gt;完成三次握手<br><br>監控握手和arp<br>tcpdump -nn -i any port <span class="hljs-number">80</span> or arp<br></code></pre></td></tr></table></figure><h3 id="完成arp協議後再握手"><a href="#完成arp協議後再握手" class="headerlink" title="完成arp協議後再握手"></a>完成arp協議後再握手</h3><h1 id="鏈路層"><a href="#鏈路層" class="headerlink" title="鏈路層"></a>鏈路層</h1><hr><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs coq">有一個客戶和服務端<br>客戶端架了一個路由[路由有自己的mark和地址] =&gt;和客戶端有連線<br>中間有其他運營商或其他路由器<br>最後再到服務端<br><br>主機的時候=&gt;目標ip-&gt;服務器的<br>=&gt;mark地址-&gt;路由器的(下一跳)<br><br>數據包發送給路由器=&gt;和路由表對應(發現不是自己)=&gt;轉發-&gt;mark地址會運營商(ip永遠只向服務端)<br><br>運營商發現無法匹配(將mark轉成下級[服務端]) =&gt;找到服務器<br><br>每跳一次mark都發生變化,ip地址永遠只向服務端<br><br>端到端=&gt;ip<br>節點到節點 =&gt;mark地址<br>-----------------------------<br>數據包中出現兩套ip地址=&gt;隧道技術(vpn)<br><br>中國想訪問其他國家網站在香港架了一個路由<br>數據包背著兩個ip,內網是其他國家網站的ip地址,用外網包裝(外網指向香港的路由<br>所以數據包會先到香港再到其他國家<br><br>外網=&gt;外部人經過端口都能訪問<br>－－－－－－－－－－－－－－－－－－<br>使用DNAT和SNAT可以改變ip地址<br><br>附載均衡器=&gt;轉發<br>有一個server1(能建立<span class="hljs-number">5000</span>連結)和server2(建立<span class="hljs-number">5000</span>)在前面有附載均衡<br>當客戶端傳送資訊會透過附載均衡器分別傳送到server1和server2<br>=&gt;避免高並發<br><br>在附載均衡時,有一個原子性不能被打破<br>lvs(負載均衡服務器)不會和客戶端握手=&gt;類似路由器<br><br>有一個syn=&gt;會發送到lvs轉發的服務端server1<br>server1回傳給客戶端syn+ack<br>客戶端傳ack給服務端=&gt;此時lvs不能轉發給非發出最原始的syn的服務器<br>協議就是約束<br><br></code></pre></td></tr></table></figure><h3 id="Ddos原理"><a href="#Ddos原理" class="headerlink" title="Ddos原理"></a>Ddos原理</h3><p>客戶端透過lvs的約束來讓ack只能傳給指定服務端</p><p>不斷創造(假)客戶端並瘋狂傳送ack導致服務端過載</p><p>當真實訪問服務端的ack發送時就發生請求失敗</p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><hr><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">假設有個本機docker具有非常多容器但需要同時請求一個服務端(容器）<br>此時如果使用握手會造成請求時間過長,速度慢<br>因此在本機內新增一個容器讓其他容器先連結到他再用他連結到服務器<br>=&gt;本機內握手時間短<br>但服務端返回時發現並不知道是哪個客戶端請求=&gt;HTTP無狀態(連結復用,須避免)<br>因此調用RPC讓無狀態變成有狀態(此時服務端需新增一個rpc位置(容器）讓rpc的客戶端請求-&gt;再連結到真實服務端)<br>=&gt;每個請求傳輸前都掛上request id,服務端返回時變知道是哪個客戶端所傳送的了<br></code></pre></td></tr></table></figure><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><hr><p>為什麼要學習io?</p><p>io無處不在(tomcat,redis,kafka,nginx),對於性能至關重要</p><p>IO→學習網路通信IO(socket)→BIO NIO 多路複用器</p><p>計算機組成原理</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs excel">按下開機後,第一個程序為內核(硬盤加載進內存)=&gt;內核為程序=&gt;對外管理io設備<br>內核和程序相當於管理層,內核加載網卡後其他程序可以不用手動加載<br><br>開機後,內核加載至內存,cpu執行內核指令後<br>=&gt;內核會把內核所在地址空間至為內核空間,其他空間為用戶空間<br>=&gt;啟動保護模式(用戶空間沒辦法訪問內核空間,但內核空間可以完全訪問用戶空間)=&gt;減少對系統破壞<br><br>但用戶空間的app會用到內核所管理的外部硬件,因此還是需要有辦法訪問內核<br>=&gt;中斷,系統調用<br><br>App產生系統調用而非函數調用,會將函數轉換成系統(調用)=&gt;使用<span class="hljs-built_in">INT</span> <span class="hljs-symbol">x80</span>(軟體中斷)=&gt;訪問內核<br>用戶想要訪問內核都需要調用中斷<br></code></pre></td></tr></table></figure><h3 id="dtruss指令"><a href="#dtruss指令" class="headerlink" title="dtruss指令"></a>dtruss指令</h3><h1 id="http加密"><a href="#http加密" class="headerlink" title="http加密"></a>http加密</h1><p>如果明文傳輸內容容易被獲得</p><p>C為客戶，S為服務，f為加密函數</p><p>使用對稱加密（如果每個都有k就安全，因此單純非對稱加密並不安全)</p><hr><p>f(k,data)&#x3D;x</p><p>f2(k,x)&#x3D;data</p><p>C-&gt;S 傳輸x</p><p>S解密x得data,也能傳輸給Cx</p><p>K只有一個，所有人都用相同K，容易被破解</p><p>非對稱加密（c對s安全，s對c不安全)</p><hr><p>pk所有人都能拿</p><p>sk只有服務端能拿</p><p>C-&gt;S拿pk</p><p>f(pk,data)&#x3D;y</p><p>f(sk,y)&#x3D;data</p><p>f(sk,data)&#x3D;y’-&gt;被拿到pk，被破解</p><p>f(pk,y’)&#x3D;data</p><p>結合兩種加密（產生中間人問題)</p><hr><p>S有pk,sk</p><p>使用非對稱加密達成協商獲得k</p><p>再使用對稱加密使用k交互數據</p><p>C-&gt;S拿pk</p><p>C加密數據y給S</p><p>S解密數據y，並且將y當非對稱加密k</p><p>S通知服務端新的K</p><p>再使用對稱加密k進行數據交互</p><p>看似安全，但可是</p><hr><p>黑客如果攔截pk,sk</p><p>C拿到黑客的pk，黑客像S請求真實pk</p><p>C傳送數據data給黑客加密，再被攔截</p><p>被黑客用自己的sk攔截，再傳ok(使用對稱加密</p><p>黑客像服務端發送數據(藉由pk加密)請求使用對稱加密，服務端傳送ok</p><p>黑客成為C和S的中間人，獲得所有信息</p><p>解決中間人問題</p><hr><p>因為在第一步被黑客介入，不知道公鑰是否正確</p><p>引入CA (檢查公鑰正確性)，CA具有cpk和csk</p><p>先將pk進行加密</p><p>pk&#x3D;&gt;f(csk ,pk)&#x3D;license給S</p><p>C請求license，得到cpk 就能解密</p><p>但C對CA機構拿cpk 有可能被截獲，因此直接將cpk寫死在操作系統C端</p><p>因此C端能直接對license解密，然後協商k 接著對稱加密，交互信息</p><p>保證pk的絕對安全性</p><p>如果此時還有中間人(黑客</p><p>獲取證書的部分是不可能介入的,license不安全，出現警告且無法訪問</p><p>黑客只拿到pk,當C傳輸時無法解密(需要sk</p><p>對稱+非對稱+CA</p><p>協商過程</p><hr><p>訪問百度</p><p>1 C-&gt;S 支持SSL版本,非對稱算法,隨機數1</p><p>2 S-&gt;C 就用SSL版本,對稱算法,隨機數 2,CA證書</p><p>3 C認證證書</p><p>證書認證成功：</p><p>4 C-&gt;S 隨機數3，hash(1,2)&#x3D;xx</p><p>5 S驗證xx&#x3D;&#x3D;hash(1,2)&#x3D;&gt;隨機數1,2,3生成k</p><p>6 S-&gt;C hash(1,2,4)&#x3D;zz</p><p>7 C hash(1,2,4)&#x3D;&#x3D;zz?&#x3D;&gt;隨1,2,3生成k</p><p>5和7的k會相同</p>]]></content>
    
    
    
    <tags>
      
      <tag>網路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gonlang-im</title>
    <link href="/2022/12/23/gonlang-im/"/>
    <url>/2022/12/23/gonlang-im/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>後端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue+element項目</title>
    <link href="/2022/12/22/vue-element%E9%A0%85%E7%9B%AE/"/>
    <url>/2022/12/22/vue-element%E9%A0%85%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="模訪項目vue-element"><a href="#模訪項目vue-element" class="headerlink" title="模訪項目vue+element"></a>模訪項目vue+element</h2><p><a href="https://blog.csdn.net/u010174083/article/details/119065315?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167170804916800182778140%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167170804916800182778140&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119065315-null-null.142%5Ev68%5Ewechat_v2,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control2&utm_term=vue3.0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98&spm=1018.2226.3001.4187">原文網址</a></p><hr><h4 id="使用vue-cli構建"><a href="#使用vue-cli構建" class="headerlink" title="使用vue-cli構建"></a>使用vue-cli構建</h4><h2 id="在終端輸入vue-create-項目名稱"><a href="#在終端輸入vue-create-項目名稱" class="headerlink" title="在終端輸入vue create [項目名稱]"></a>在終端輸入<br><code>vue create [項目名稱]</code></h2><h4 id="使用vue-cli安裝element-ui"><a href="#使用vue-cli安裝element-ui" class="headerlink" title="使用vue-cli安裝element-ui"></a>使用vue-cli安裝element-ui</h4><p>在終端輸入<br><code>vue add element-plus </code></p><p>項目文件出現的 <em>element-variables.scss</em></p><hr><h4 id="引入http请求框架axios"><a href="#引入http请求框架axios" class="headerlink" title="引入http请求框架axios"></a>引入http请求框架axios</h4><p>在終端輸入</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">npm install axios</span> <span class="hljs-literal">--</span><span class="hljs-comment">legacy</span><span class="hljs-literal">-</span><span class="hljs-comment">peer</span><span class="hljs-literal">-</span><span class="hljs-comment">deps</span> <span class="hljs-literal">--</span><span class="hljs-comment">save</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo操作</title>
    <link href="/2022/12/21/123/"/>
    <url>/2022/12/21/123/</url>
    
    <content type="html"><![CDATA[<h3 id="hexo-new來新增部落格"><a href="#hexo-new來新增部落格" class="headerlink" title="hexo new來新增部落格"></a>hexo new來新增部落格</h3><h3 id="hexo-g-c創造html欓案"><a href="#hexo-g-c創造html欓案" class="headerlink" title="hexo g -c創造html欓案"></a>hexo g -c創造html欓案</h3><h3 id="hexo-d-將檔案推上github"><a href="#hexo-d-將檔案推上github" class="headerlink" title="hexo d 將檔案推上github"></a>hexo d 將檔案推上github</h3><hr>]]></content>
    
    
    
    <tags>
      
      <tag>指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
